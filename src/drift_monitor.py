import json
import os
from typing import Any, Dict, List, Tuple
from datetime import datetime

import google.generativeai as genai

GEMINI_MODEL = os.getenv("GEMINI_MODEL", "gemini-1.5-pro")


def _ensure_genai():
    api_key = os.getenv("GEMINI_API_KEY")
    if api_key:
        genai.configure(api_key=api_key)


def _span_overlap(a: Tuple[int, int], b: Tuple[int, int]) -> int:
    return max(0, min(a[1], b[1]) - max(a[0], b[0]))


def _match_entities(preds: List[Dict[str, Any]], labels: List[Dict[str, Any]]) -> Tuple[int, int, int]:
    tp = 0
    fp = 0
    fn = 0
    used = set()
    for p in preds:
        p_span = (int(p.get('start', -1)), int(p.get('end', -1)))
        p_type = str(p.get('type', ''))
        matched = False
        for i, l in enumerate(labels):
            if i in used:
                continue
            l_span = (int(l.get('start', -1)), int(l.get('end', -1)))
            l_type = str(l.get('type', ''))
            if p_type == l_type and _span_overlap(p_span, l_span) > 0:
                tp += 1
                used.add(i)
                matched = True
                break
        if not matched:
            fp += 1
    fn = len(labels) - len(used)
    return tp, fp, fn


def evaluate_dataset(samples: List[Dict[str, Any]], detector) -> Tuple[Dict[str, float], List[Dict[str, Any]]]:
    """Evaluate precision/recall on labeled set.
    samples: [{text, label_entities: [...]}]
    Returns (metrics, false_positive_samples)
    """
    total_tp = total_fp = total_fn = 0
    fp_samples: List[Dict[str, Any]] = []
    for s in samples:
        text = s.get('text', '')
        labels = s.get('label_entities', [])
        preds = detector(text) or []
        tp, fp, fn = _match_entities(preds, labels)
        total_tp += tp
        total_fp += fp
        total_fn += fn
        if fp > 0:
            fp_samples.append({'text': text, 'preds': preds, 'labels': labels})
    precision = total_tp / (total_tp + total_fp) if (total_tp + total_fp) else 0.0
    recall = total_tp / (total_tp + total_fn) if (total_tp + total_fn) else 0.0
    f1 = 2 * precision * recall / (precision + recall) if (precision + recall) else 0.0
    fp_rate = total_fp / max(1, (total_tp + total_fp))
    return {
        'precision': precision,
        'recall': recall,
        'f1': f1,
        'fp_rate': fp_rate,
        'tp': float(total_tp),
        'fp': float(total_fp),
        'fn': float(total_fn),
    }, fp_samples


def propose_regex_improvements(fp_samples: List[Dict[str, Any]]) -> List[str]:
    """Use Gemini to suggest regex refinements given false positives.
    Returns list of suggestion strings.
    """
    _ensure_genai()
    if not os.getenv('GEMINI_API_KEY'):
        # Heuristic fallback
        return [
            "Add word boundaries to numeric patterns (e.g., use \\b around \\d+)",
            "Exclude known non-PII prefixes with negative lookahead",
        ]
    prompt = (
        "You are improving PII regex rules. Given examples of false positives (predictions that should not be PII),\n"
        "suggest specific regex refinements to reduce FPs without hurting recall.\n"
        "Return a bullet list, each item a single-line actionable change.\n\n"
        f"False positive samples (JSON):\n{json.dumps(fp_samples)[:4000]}\n"
    )
    model = genai.GenerativeModel(GEMINI_MODEL)
    try:
        resp = model.generate_content(prompt)
        text = (resp.text or '').strip()
        # Return each line as a suggestion
        return [line.strip('- ').strip() for line in text.splitlines() if line.strip()]
    except Exception:
        return ["Tighten numeric patterns with boundaries and context-based exclusions."]


essay_header = """# Regex Improvement Proposal\n\nThe drift monitor detected elevated false positives. This PR proposes the following rule updates:\n"""


def write_mock_pr(suggestions: List[str]) -> str:
    ts = datetime.utcnow().strftime('%Y%m%d-%H%M%S')
    pr_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'data', 'prs'))
    os.makedirs(pr_dir, exist_ok=True)
    path = os.path.join(pr_dir, f"regex-improvements-{ts}.md")
    with open(path, 'w', encoding='utf-8') as f:
        f.write(essay_header)
        for s in suggestions:
            f.write(f"\n- {s}")
        f.write("\n\n> Generated by Drift Monitor")
    return path
